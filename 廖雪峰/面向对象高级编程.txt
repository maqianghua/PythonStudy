1 本节介绍的是最常用的几个定制方法，还有很多可定制的方法，请参考Python的官方文档：http://docs.python.org/3/reference/datamodel.html#special-method-names
面向对象高级编程
1. 数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能

面向对象高级编程_使用__slots__
1. 正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性
2. 给一个实例绑定的方法，对另一个实例是不起作用的
3. 为了给所有实例都绑定方法，可以给class绑定方法：
4. 上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现
5. 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性
6. 由于'score'没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误
7. 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__

面向对象高级编程_使用@property
1. 还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的
2. 注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的
3. 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性
4. @property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性

面向对象高级编程_多重继承
1. 继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能
2. 对于需要Runnable功能的动物，就多继承一个Runnable
3. 通过多重继承，一个子类就可以同时获得多个父类的所有功能
4. Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来
5. 这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类
6. 只允许单一继承的语言（如Java）不能使用MixIn的设计；由于Python允许使用多重继承，因此，MixIn就是一种常见的设计

面向对象高级编程_定制类
__str__;__iter__;__getitem__;__getattr__;__call__;（__member__枚举）

1. 看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的
2. 除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类
3. 这是因为直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的
4. 解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：__repr__=__str__
5. 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环
6. __next__只有python3.6版本中有，2.7里面没有。（相对于我的电脑装的python版本而言）
7. Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素
8. 要表现得像list那样按照下标取出元素，需要实现__getitem__()方法
9. 与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素
10. 总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。
11. 要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性
12. 返回函数也是完全可以的；只是调用方式要变为
13. 注意：只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找
14. 此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误
15. 这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。
16. 利用完全动态的__getattr__，我们可以写出一个链式调用
17:__call__;任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例
18. 一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的
19. 那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call__()的类实例
20. __call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别
21. 通过callable()函数，我们就可以判断一个对象是否是“可调用”对象
面向对象高级编程_使用枚举类
1. 当我们需要定义常量时，一个办法是用大写变量通过整数来定义
2. 好处是简单，缺点是类型是int，并且仍然是变量
3. 更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能
4. 可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量
5. Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较

面向对象高级编程_使用元类
1. 动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的
2. type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello
3. 我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数
4. type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)...的定义
5. 要创建一个class对象，type()函数依次传入3个参数
	5.1 class的名称
	5.2 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法：（元素1，）：注意千万不能忘了逗号
	5.3 class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。
6. 通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class
7. 除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass
8. metaclass，直译为元类，简单的解释就是：当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。
9. 先定义metaclass，就可以创建类，最后创建实例
10. metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”
11. 当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义
12. __new__()方法接收到的参数依次是：
	12.1 当前准备创建的类的对象；
	12.2 类的名字
	12.3 类继承的父类集合
	12.4 类的方法集合
13. 动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态
14. ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。
15. 要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来
16. 当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到
17. 在ModelMetaclass中，一共做了几件事情
	17.1 排除掉对Model类的修改
	17.2 在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）
	17.3 把表名保存到__table__中，这里简化为表名默认为类名
18. metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心