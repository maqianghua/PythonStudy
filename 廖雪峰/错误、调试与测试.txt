错误、调试与测试
1.我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码
2. 编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试

错误、调试与测试_错误处理
1. 一旦出错，还要一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息
2. 所以高级语言通常都内置了一套try...except...finally...的错误处理机制，Python也不例外
3. 你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，可以有多个except来捕获不同类型的错误：
4. Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如
5. 第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了
6. 使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理
7. 也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写try...except...finally的麻烦
8. 如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。来看看err.py
9. 出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置
10. Python内置的logging模块可以非常容易地记录错误信息；通过配置，logging还可以把错误记录到日志文件里，方便事后排查；（logging.exception(e))
11. 只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型
12. raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型
13. 只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError

错误、调试与测试_调试
1. 第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看
2. 凡是用print()来辅助查看的地方，都可以用断言（assert）来替代
3. 如果断言失败，assert语句本身就会抛出AssertionError
4. 程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert；关闭后，你可以把所有的assert语句当成pass来看
5. 把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件；在import logging后面添加一行配置logging.basicConfig(level=logging.INFO)
6. 这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件
7. 以参数-m pdb启动后，pdb定位到下一步要执行的代码-> s = '0'。输入命令l来查看代码;输入命令n可以单步执行代码;任何时候都可以输入命令p 变量名来查看变量;输入命令q结束调试，退出程序
8. 这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点.pdb.set_trace()#运行到这里会自动暂停。
9. 运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行
10. IDE：如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有：Visual Studio Code：https://code.visualstudio.com/，需要安装Python插件。PyCharm：http://www.jetbrains.com/pycharm/；另外，Eclipse加上pydev插件也可以调试Python程序
11. 虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器

错误、调试与测试_单元测试
1. 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作
2. 如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生
3. 比如对函数abs()，我们可以编写出以下几个测试用例
	3.1 输入正数，比如1、1.2、0.99，期待返回值与输入相同
	3.2 输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反
	3.3 输入0，期待返回0
	3.4 输入非数值类型，比如None、[]、{}，期待抛出TypeError
4. 可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行
5. setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码

错误、调试与测试_文档测试
1. 如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如re模块就带了很多示例代码：
2. 这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？答案是肯定的。
3. Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试
4. doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest

